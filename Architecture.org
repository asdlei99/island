* Project Architecture

1. The project is organised into independent subsystems
2. Each subsystem is fully contained within its own library
3. Libraries may be static or dynamic - there shall be no difference in program function
4. Dynamic libraries may be reloaded while the program is running

* Library Architecture 

1. Each Library must provide exactly one free function with c-linkage: `register_${library_name}_api` - the library registration function
2. The library registration function is responsible for connecting function pointers declared in the library interface to free functions defined in the implementation (.cpp) files of the library.
3. Library must declare its interface through a struct named `pal_${library_name}_api`
4. Library interface struct must provide two fields:
   1. `static constexpr auto id` - this field must be a string literal, and its value must be the value of ${library_name}, i.e. the unique name of the library.
   2. `static constexpr auto pRegFun` - contains the address of the library registration function
5. A library may have a number of objects which it may instantiate.

* Object Architecture

We treat objects as structured data, with functions associated with them. Objects don't own their functions, but may have a vtable pointer, which contains just the methods relevant to manipulating the object. Object data is kept secret, only the object library's implementation may touch and manipulate object data.

1. An object is declared as an opaque struct in library header files
2. Objects data must be private - to interact with objects clients of the library must use the library interface for the object
3. Objects must provide `create` and `destroy` methods.
4. Object interfaces may be declared as inner structs of the library interface struct.

* Implementation rules

The Biedermeyer principle: "Public appearance must be pure, private life can be the most promiscuous mess (although we all try to be good)"

* Library Header Rules

Header files must follow strict rules, and c-interfaces must be "holier-than-thou". 

1. must not include any cpp headers.
2. must not include any other library headers
3. may forward-declare elements needed from other libraries
4. may include <stdint.h>

** Private headers
   1. Modules may define private headers
   2. Private headers go in a sub-folder `private`
   3. Private headers can be included from all `.cpp` files inside a module.
   4. Private headers can include other headers as long as they are from the same module. 

* Implementation file Rules 

Implementations may do whatever they see fit - as long as it never seeps into the header file.

1. may include any library header
2. may include any cpp header
3. may use advanced cpp 

* Library programming
	
Library cpp file must not assume to own any data - if it has any static or global variables, these must be assumed invalid after reload, and must be re-assigned (patched).


* Caveats

when hot-reloading, function pointers will be re-assigned. be careful when hot- adding and then calling new static methods to libraries, as these might not be found when called. It seems possible to change the contents of functions which are defined before the first start, so changing the logic of existing methods (and calling them at will) appears to work.

* vulkan types in interfaces

In headers, we forward-declare and use `struct VkType_T*` in interfaces for non-dispatchable handles. In implementation files which include vulkan.h, these types will be recognised as what they are when matched with the correct vulkan type: `VkType`. 

* Types in engine interfaces 

In headers, we forward-declare and use `struct engine_type_o*` for engine types which are passed between plug-ins. The implementations might use each other's private headers to get acces into these handles (like friend, and not very elegant), or use the public headers, and the Registry to call methods on the handles to interrogate the objects in an opaque way.

* Engine internals

** use of resources

   1. Any resource used in renderpass must be declared in the renderpass' setup callback.
   2. Any declared resource will be tracked
   3. Tracked means: sync state, layout (for images) 

* Thoughts

** Renderer Architecture: 

   1. We should not store state with graphbuilder - instead use graph builder to manipulate frame state - memory which belongs to that particular frameData.
   2. We need a way to record commands in an abstraction of command buffers, so that the backend can translate these commands back to an api specific version of command buffers.
   3. We might need some commands to operate on resources - these need syncing inserted at the correct time. 
   

